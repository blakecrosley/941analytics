{% extends "base.html" %}

{% block title %}Geography{% endblock %}

{% block content %}
{% include "partials/geography_content.html" %}
{% endblock %}

{% block scripts %}
{% if config.enable_globe %}
<script>
    // Lazy load Three.js globe when user scrolls to it or clicks "Load Globe"
    function loadGlobe() {
        const container = document.getElementById('globe-container');
        if (!container || container.dataset.loaded === 'true') return;

        // Clear container safely and show loading
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.textContent = 'Loading 3D globe...';
        container.appendChild(loadingDiv);
        container.dataset.loaded = 'true';

        // Dynamically load Three.js
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/three@0.158.0/build/three.min.js';
        script.onload = function() {
            // Load OrbitControls after Three.js
            const controls = document.createElement('script');
            controls.src = 'https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js';
            controls.onload = initGlobe;
            document.head.appendChild(controls);
        };
        document.head.appendChild(script);
    }

    function initGlobe() {
        const container = document.getElementById('globe-container');
        const data = JSON.parse(document.getElementById('globe-data').textContent);

        const width = container.clientWidth;
        const height = 400;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.z = 2.5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Clear container safely and add canvas
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        container.appendChild(renderer.domElement);

        // Earth sphere
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const material = new THREE.MeshBasicMaterial({
            color: 0x1a1a1a,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const earth = new THREE.Mesh(geometry, material);
        scene.add(earth);

        // Add points for countries
        data.countries.forEach(function(country) {
            if (!country.lat || !country.lon) return;

            const phi = (90 - country.lat) * (Math.PI / 180);
            const theta = (country.lon + 180) * (Math.PI / 180);

            const x = -Math.sin(phi) * Math.cos(theta);
            const y = Math.cos(phi);
            const z = Math.sin(phi) * Math.sin(theta);

            const size = Math.min(0.05, Math.max(0.02, country.visits / 100 * 0.02));
            const pointGeometry = new THREE.SphereGeometry(size, 8, 8);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const point = new THREE.Mesh(pointGeometry, pointMaterial);
            point.position.set(x * 1.02, y * 1.02, z * 1.02);
            scene.add(point);
        });

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', function() {
            const newWidth = container.clientWidth;
            camera.aspect = newWidth / height;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, height);
        });
    }
</script>
{% endif %}
{% endblock %}
